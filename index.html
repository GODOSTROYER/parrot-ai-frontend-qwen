<script>
        document.addEventListener("DOMContentLoaded", () => {
            let mediaRecorder;
            let audioChunks = [];
            let isRefRecording = false;

            // No need for MP3 encoding with LAMEJS anymore

            // --- NEW: SVG Icon definitions ---
            const micIconSVG = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4 4.9V14h1.5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1H7v-1.1A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/>
                  <path d="M5 0a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V0z"/>
                </svg>`;
            
            const stopIconSVG = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/>
                </svg>`;


            // --- Reference Audio Recording (with icon swapping) ---
            recordBtn.addEventListener("click", () => {
                if (isRefRecording) {
                    mediaRecorder.stop();
                } else {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            isRefRecording = true;
                            recordBtn.classList.add("is-recording");
                            recordBtnIcon.innerHTML = stopIconSVG;
                            recordBtnText.textContent = "Stop Recording";
                            
                            fileInput.value = null;
                            referenceAudioFile = null;
                            fileNameDisplay.textContent = "Recording... (aim for 3-10 seconds)";
                            fileNameDisplay.style.color = "var(--danger)";
                            
                            const options = { mimeType: 'audio/wav' };
                            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                                // Fallback to default format (usually webm)
                                console.warn("audio/wav not supported, using default format.");
                            }
                            
                            mediaRecorder = new MediaRecorder(stream, options);
                            audioChunks = []; 
                            mediaRecorder.ondataavailable = event => { audioChunks.push(event.data); };

                            mediaRecorder.onstop = async () => {
                                isRefRecording = false;
                                recordBtn.classList.remove("is-recording");
                                recordBtnIcon.innerHTML = micIconSVG;
                                recordBtnText.textContent = "Record Reference Audio";
                                
                                stream.getTracks().forEach(track => track.stop());
                                
                                try {
                                    const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/wav' });
                                    
                                    // Determine the file extension based on mime type
                                    let fileName = "recorded_reference.wav";
                                    if (mediaRecorder.mimeType && mediaRecorder.mimeType.includes('webm')) {
                                        fileName = "recorded_reference.webm";
                                    } else if (mediaRecorder.mimeType && mediaRecorder.mimeType.includes('mp4')) {
                                        fileName = "recorded_reference.m4a";
                                    }
                                    
                                    referenceAudioFile = new File([audioBlob], fileName, {
                                        type: audioBlob.type,
                                        lastModified: Date.now()
                                    });
                                    updateFileName(referenceAudioFile);
                                } catch (error) {
                                    console.error("Error processing audio:", error);
                                    showStatus("Error: Could not process audio. " + error.message, true);
                                    updateFileName(null);
                                }
                            };
                            mediaRecorder.start();
                        })
                        .catch(err => {
                            console.error("Error accessing microphone:", err);
                            showStatus("Error: Could not access microphone. " + err.message, true);
                            updateFileName(null);
                        });
                }
            });

        });
    </script>
</html>
